// Generated by CoffeeScript 2.3.1
(function() {
  var ARENA_HEIGHT, ARENA_WIDTH, ATTACK_DAMAGE_BLING, ATTACK_DAMAGE_RING, ATTACK_RANGE_BLING, ATTACK_RANGE_RING, ATTACK_RATE_RING, Arena, BERSERK_DURATION, BLING_SPAWN_CENTER, Bling, COLOR_BLING, COLOR_RING, COLOR_RING_BERSERK, CollisionGrid, DirectionIndicator, Entity, Explosion, FPS, FadeAway, GRID_SIZE, HP_BLING, HP_RING, MAX_SPEED_BLING, MAX_SPEED_RING, MOVE_ATTACK, MOVE_NORMAL, MoveIndicator, Projectile, RADIUS, RADIUS_2, RING_SPAWN_CENTER, Ring, SELECTOR_BORDER, SELECTOR_FILL, Selector, arena, context;

  ARENA_WIDTH = 960;

  ARENA_HEIGHT = 500;

  GRID_SIZE = 20;

  FPS = 60;

  RADIUS = 9;

  RADIUS_2 = RADIUS * RADIUS;

  SELECTOR_FILL = 'rgba(102,255,0,0.1)';

  SELECTOR_BORDER = 'green';

  MOVE_NORMAL = 0;

  MOVE_ATTACK = 1;

  RING_SPAWN_CENTER = [200, 200];

  BLING_SPAWN_CENTER = [800, 400];

  COLOR_RING = 'rgb(50,100,255)';

  COLOR_RING_BERSERK = 'rgb(30,180,255)';

  HP_RING = 45;

  MAX_SPEED_RING = 2.25 * 40 / FPS;

  ATTACK_RATE_RING = ~~(0.8608 * FPS);

  ATTACK_RANGE_RING = 160;

  ATTACK_DAMAGE_RING = 6;

  BERSERK_DURATION = 15 * FPS;

  COLOR_BLING = 'rgb(102,255,0)';

  HP_BLING = 30;

  MAX_SPEED_BLING = 2.9531 * 40 / FPS; // 2.5

  ATTACK_RANGE_BLING = 160 / 3;

  ATTACK_DAMAGE_BLING = 35;

  arena = document.getElementById('arena');

  arena.width = ARENA_WIDTH;

  arena.height = ARENA_HEIGHT;

  context = arena.getContext('2d');

  Entity = class Entity {
    constructor(kwargs) {
      this.radius = RADIUS;
      this.flags = {
        moving: false,
        selected: false,
        finished: false
      };
      this.properties = {
        collides: true,
        selectable: false
      };
      this.max_speed = false;
      this.move_queue = [];
      this.position = (kwargs != null ? kwargs.position : void 0) || false;
      this.target_position = false;
      this.direction = false;
      this.frame_offset = ~~(Math.random() * 100);
    }

    draw() {
      context.beginPath();
      context.arc(this.position[0], this.position[1], this.radius, 2 * Math.PI, false);
      context.fillStyle = this.color;
      if (this.flags.selected) {
        context.strokeStyle = 'lightgreen';
        context.lineWidth = 3;
        context.stroke();
      }
      return context.fill();
    }

    mainLoop() {
      if (this.flags.moving || this.move_queue.length > 0) {
        this.calculateNewPosition();
      }
      return this.draw();
    }

    calculateNewPosition() {
      var direction, m, vector;
      if (this.move_queue.length > 0 && this.flags.moving === false) {
        return this.move(this.move_queue.shift());
      } else {
        vector = [this.target_position[0] - this.position[0], this.target_position[1] - this.position[1]];
        m = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        vector = [vector[0] * this.max_speed / m, vector[1] * this.max_speed / m];
        direction = [vector[0] > 0, vector[1] > 0];
        if (direction[0] !== this.direction[0] || direction[1] !== this.direction[1]) {
          this.flags.moving = false;
          return this.direction = false;
        } else {
          return this.setPosition([this.position[0] + vector[0], this.position[1] + vector[1]]);
        }
      }
    }

    move(position, queue = false) {
      if (queue) {
        return this.move_queue.push(this.boundedPosition(position));
      } else {
        this.setTargetPosition(position);
        this.direction = [this.target_position[0] - this.position[0] > 0, this.target_position[1] - this.position[1] > 0];
        return this.flags.moving = true;
      }
    }

    boundedPosition(position) {
      if (position[0] <= this.radius) {
        position[0] = this.radius + Math.random() * 0.5;
      }
      if (position[0] >= ARENA_WIDTH - this.radius) {
        position[0] = ARENA_WIDTH - this.radius;
      }
      if (position[1] <= this.radius) {
        position[1] = this.radius + Math.random() * 0.5;
      }
      if (position[1] >= ARENA_HEIGHT - this.radius) {
        position[1] = ARENA_HEIGHT - this.radius;
      }
      return position;
    }

    setTargetPosition(position) {
      return this.target_position = this.boundedPosition(position);
    }

    setPosition(position) {
      return this.position = this.boundedPosition(position);
    }

    destroy() {
      return this.flags.finished = true;
    }

  };

  Bling = class Bling extends Entity {
    constructor(kwargs) {
      super(kwargs);
      this.hp = HP_BLING;
      this.max_speed = MAX_SPEED_BLING;
      this.color = COLOR_BLING;
      this.target = false;
    }

    takeDamage(hp) {
      this.hp -= hp;
      this.color = 'orange';
      if (this.hp <= 0 && !this.flags.finished) {
        this.destroy();
        return BvR.selectors.kills.innerText = ++BvR.stats.kills;
      }
    }

    checkNearbyEnemies() {
      var d2, e, i, ref, results, x, y;
      ref = BvR.arena.entities;
      results = [];
      for (i in ref) {
        e = ref[i];
        if (e instanceof Ring && !e.flags.finished) {
          x = e.position[0] - this.position[0];
          y = e.position[1] - this.position[1];
          d2 = Math.pow(x, 2) + Math.pow(y, 2);
          if (d2 < Math.pow(ATTACK_RANGE_BLING / 2, 2)) {
            this.destroy();
            break;
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    animate() {
      if (BvR.frame % 2 === 0) {
        this.color = COLOR_BLING;
      }
      switch ((BvR.frame + this.frame_offset) % FPS) {
        case 0:
          return this.radius = RADIUS;
        case 21:
          return this.radius = RADIUS * 1.08;
        case 25:
          return this.radius = RADIUS * 1.15;
        case 29:
          return this.radius = RADIUS * 1.08;
        case 33:
          return this.radius = RADIUS;
      }
    }

    mainLoop() {
      super.mainLoop();
      this.animate();
      this.checkNearbyEnemies();
      if (BvR.frame % 5 === 0) {
        return this.attackNearest();
      }
    }

    draw() {
      super.draw();
      context.strokeStyle = 'darkgreen';
      context.lineWidth = 2;
      return context.stroke();
    }

    destroy() {
      var e;
      e = new Explosion({
        position: this.position,
        radius: ATTACK_RANGE_BLING,
        damage: ATTACK_DAMAGE_BLING
      });
      BvR.arena.addEntity(e);
      return this.flags.finished = true;
    }

    attackNearest() {
      var candidates, closest, d2, e, i, ref, target, x, y;
      candidates = [];
      ref = BvR.arena.entities;
      for (i in ref) {
        e = ref[i];
        if (e instanceof Ring) {
          [x, y] = [e.position[0] - this.position[0], e.position[1] - this.position[1]];
          d2 = Math.pow(x, 2) + Math.pow(y, 2);
          candidates.push([d2, i]);
        }
      }
      if (candidates.length > 0) {
        closest = candidates.sort()[0];
        if (target = BvR.arena.entities[this.target_id]) {
          [x, y] = target.position;
          d2 = Math.pow(x, 2) + Math.pow(y, 2);
          if (closest[0] < 0.1 * d2) {
            this.target_id = closest[1];
          }
        } else {
          this.target_id = closest[1];
        }
        target = BvR.arena.entities[this.target_id];
        return this.move(target.position);
      }
    }

  };

  Ring = class Ring extends Entity {
    constructor(kwargs) {
      super(kwargs);
      this.hp = HP_RING;
      this.max_speed = MAX_SPEED_RING;
      this.attack_damage = ATTACK_DAMAGE_RING;
      this.color = COLOR_RING;
      this.berserk_start = 0;
      this.last_attack_at = 0;
      this.flags.berserk = false;
      this.properties.selectable = true;
      ++BvR.stats.units;
    }

    checkNearbyEnemies() {
      var candidates, d2, e, i, p, ref, target, x, y;
      candidates = [];
      ref = BvR.arena.entities;
      for (i in ref) {
        e = ref[i];
        if (e instanceof Bling) {
          x = e.position[0] - this.position[0];
          y = e.position[1] - this.position[1];
          d2 = Math.pow(x, 2) + Math.pow(y, 2);
          if (d2 < Math.pow(ATTACK_RANGE_RING, 2)) {
            candidates.push([d2, i]);
          }
        }
      }
      if (candidates.length > 0) {
        candidates.sort();
        target = BvR.arena.entities[candidates[0][1]];
        p = new Projectile({
          position: this.position,
          target: target,
          damage: this.attack_damage
        });
        BvR.arena.addEntity(p);
        this.last_attack_at = BvR.frame;
        return this.color = 'yellow';
      }
    }

    draw() {
      super.draw();
      context.strokeStyle = '#2f2f2f';
      context.lineWidth = 1;
      return context.stroke();
    }

    mainLoop() {
      if (this.flags.berserk) {
        if (this.berserk_start + BERSERK_DURATION > BvR.frame) {
          this.max_speed = MAX_SPEED_RING * 1.5;
          this.attack_damage = ATTACK_DAMAGE_RING * 1.5;
          if (BvR.frame % 5 === 0) {
            this.color = COLOR_RING_BERSERK;
          }
        } else {
          this.flags.berserk = false;
          this.max_speed = MAX_SPEED_RING;
          this.attack_damage = ATTACK_DAMAGE_RING;
        }
      } else {
        if (BvR.frame % 5 === 0) {
          this.color = COLOR_RING;
        }
      }
      super.mainLoop();
      if (!this.flags.moving && BvR.frame > (ATTACK_RATE_RING + this.last_attack_at)) {
        return this.checkNearbyEnemies();
      }
    }

    takeDamage(hp) {
      this.hp -= hp;
      if (this.hp <= 0) {
        return this.destroy();
      }
    }

    berserk() {
      if (this.hp > 10) {
        this.hp -= 10;
        this.flags.berserk = true;
        return this.berserk_start = BvR.frame;
      }
    }

    destroy() {
      var f;
      if (!this.flags.finished) {
        BvR.selectors.units.innerText = --BvR.stats.units;
        f = new FadeAway({
          position: this.position,
          radius: this.radius,
          color_code: [50, 100, 255]
        });
        BvR.arena.addEntity(f);
      }
      return this.flags.finished = true;
    }

  };

  FadeAway = class FadeAway {
    constructor(kwargs) {
      this.position = kwargs.position;
      this.radius = kwargs.radius;
      this.color_code = kwargs.color_code;
      this.rate = kwargs.rate || 1 / FPS;
      this.opacity = 1;
      this.setColor(this.color_code);
      this.flags = {
        finished: false
      };
    }

    draw() {
      context.beginPath();
      context.arc(this.position[0], this.position[1], this.radius, 2 * Math.PI, false);
      context.fillStyle = this.color;
      return context.fill();
    }

    mainLoop() {
      this.setColor();
      this.opacity -= this.rate;
      if (this.opacity > 0) {
        return this.draw();
      } else {
        return this.flags.finished = true;
      }
    }

    setColor() {
      return this.color = 'rgba(' + this.color_code[0] + ',' + this.color_code[1] + ',' + this.color_code[2] + ',' + this.opacity + ')';
    }

  };

  Explosion = class Explosion {
    constructor(kwargs) {
      this.position = kwargs.position;
      this.r_max = kwargs.radius;
      this.r_max_2 = Math.pow(kwargs.radius, 2);
      this.damage = kwargs.damage;
      this.radius = 0;
      this.rate = 240 / FPS;
      this.color = COLOR_BLING;
      this.flags = {
        finished: false
      };
      this.damageNearbyEnemies();
    }

    draw() {
      context.beginPath();
      context.arc(this.position[0], this.position[1], this.radius, 2 * Math.PI, false);
      context.fillStyle = this.color;
      return context.fill();
    }

    mainLoop() {
      if (this.radius >= this.r_max) {
        this.fadeOut();
        this.rate *= -1;
      }
      this.radius += this.rate;
      if (this.radius > 0) {
        return this.draw();
      } else {
        return this.destroy();
      }
    }

    damageNearbyEnemies() {
      var d2, e, i, ref, results, x, y;
      ref = BvR.arena.entities;
      results = [];
      for (i in ref) {
        e = ref[i];
        if (e instanceof Ring) {
          x = e.position[0] - this.position[0];
          y = e.position[1] - this.position[1];
          d2 = Math.pow(x, 2) + Math.pow(y, 2);
          if (d2 <= this.r_max_2) {
            results.push(e.takeDamage(this.damage));
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    fadeOut() {
      var f;
      if (!this.flags.finished) {
        f = new FadeAway({
          position: this.position,
          radius: this.r_max,
          color_code: [102, 255, 0],
          rate: 1.5 / FPS
        });
        return BvR.arena.addEntity(f);
      }
    }

    destroy() {
      return this.flags.finished = true;
    }

  };

  Projectile = class Projectile {
    constructor(kwargs) {
      this.position = kwargs.position;
      this.target = kwargs.target;
      this.damage = kwargs.damage;
      this.color = kwargs.color || 'rgba(255,255,0,0.8)';
      this.direction = [this.target.position[0] - this.position[0] > 0, this.target.position[1] - this.position[1] > 0];
      this.max_speed = 25;
      this.rate = 5;
      this.radius = 2;
      this.flags = {
        finished: false
      };
    }

    draw() {
      context.beginPath();
      context.arc(this.position[0], this.position[1], this.radius, 2 * Math.PI, false);
      context.fillStyle = this.color;
      return context.fill();
    }

    mainLoop() {
      var direction, m, vector;
      if (!this.flags.finished) {
        this.draw();
        vector = [this.target.position[0] - this.position[0], this.target.position[1] - this.position[1]];
        direction = [vector[0] > 0, vector[1] > 0];
        m = Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2));
        vector = [vector[0] * this.max_speed / m, vector[1] * this.max_speed / m];
        if (direction[0] !== this.direction[0] || direction[1] !== this.direction[1]) {
          this.flags.finished = true;
          return this.target.takeDamage(this.damage);
        } else {
          return this.position = [this.position[0] + vector[0], this.position[1] + vector[1]];
        }
      }
    }

  };

  Arena = class Arena {
    constructor() {
      this.entities = {};
      this.interval = false;
      this.waveInterval = false;
      this.counter = 0;
      this.mainLoop();
    }

    mainLoop() {
      this.interval = setInterval(() => {
        var e, i, ref, ref1, ref2;
        context.clearRect(0, 0, ARENA_WIDTH, ARENA_HEIGHT);
        ref = this.entities;
        for (i in ref) {
          e = ref[i];
          if ((ref1 = e.flags) != null ? ref1.finished : void 0) {
            this.deleteEntity(i);
          } else {
            if ((ref2 = e.properties) != null ? ref2.collides : void 0) {
              BvR.collisions.updateEntity(i, e.position);
            }
            BvR.collisions.handleCollisions(i);
            e.mainLoop();
          }
        }
        BvR.selector.draw();
        return BvR.frame++;
      }, 1000 / FPS);
      return this.waveInterval = setInterval(() => {
        if (this.noMoreBlings()) {
          return this.nextWave();
        }
      }, 1000);
    }

    noMoreBlings() {
      var e, i, ref;
      ref = this.entities;
      for (i in ref) {
        e = ref[i];
        if (e instanceof Bling) {
          return false;
        }
      }
      return true;
    }

    addEntity(e) {
      var ref;
      this.entities[this.counter] = e;
      if ((ref = e.properties) != null ? ref.collides : void 0) {
        BvR.collisions.updateEntity(this.counter, e.position);
      }
      return this.counter++;
    }

    deleteEntity(id) {
      delete BvR.collisions.id_lookup[id];
      return delete this.entities[id];
    }

    spawnEntity(count, type = Bling) {
      var angle, center, checkPositionAvailable, i, j, m, new_position, position, positions, ref, v;
      checkPositionAvailable = (position) => {
        var e, i, ref, x, y;
        ref = this.entities;
        for (i in ref) {
          e = ref[i];
          if (e instanceof type) {
            [x, y] = e.position;
            if (Math.pow(position[0] - x, 2) + Math.pow(position[1] - y, 2) < RADIUS_2 * 4) {
              return true;
            }
          }
        }
        return true;
      };
      if (type === Ring) {
        center = RING_SPAWN_CENTER;
      } else {
        center = BLING_SPAWN_CENTER;
      }
      positions = [center];
      for (i = j = 1, ref = count; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
        angle = Math.random() * 2 * Math.PI;
        m = RADIUS + 1;
        v = [m * Math.cos(angle), m * Math.sin(angle)];
        position = positions[positions.length - 1];
        new_position = [position[0] + v[0], position[1] + v[1]];
        while (!checkPositionAvailable(new_position)) {
          new_position = [position[0] + v[0], position[1] + v[1]];
        }
        positions.push(new_position);
        this.addEntity(new type({
          position: new_position
        }));
      }
      return BvR.selectors.units.innerText = BvR.stats.units;
    }

    incrementWaveNum() {
      return BvR.selectors.wave.innerText = ++BvR.stats.wave;
    }

    firstWave() {
      this.incrementWaveNum();
      this.spawnEntity(40, Ring);
      return this.spawnEntity(20, Bling);
    }

    nextWave() {
      this.incrementWaveNum();
      this.spawnEntity(10, Ring);
      return this.spawnEntity(~~((BvR.stats.wave / 4) * 20), Bling);
    }

  };

  DirectionIndicator = class DirectionIndicator {
    constructor() {
      this.properties = {
        visible: false,
        collides: false,
        selectable: false
      };
      this.begin = false;
      this.end = false;
    }

    mainLoop() {
      return this.draw();
    }

    draw() {
      if (this.begin && this.end) {
        context.moveTo(this.begin);
        context.lineTo(this.end);
        context.strokeStyle = 'green';
        return context.stroke();
      }
    }

  };

  MoveIndicator = class MoveIndicator {
    constructor(kwargs) {
      this.type = kwargs.type || MOVE_NORMAL;
      this.position = kwargs.position;
      this.flags = {
        finished: false
      };
    }

    mainLoop() {
      return this.draw();
    }

    draw() {
      var f;
      if (!this.flags.finished) {
        f = new FadeAway({
          position: this.position,
          radius: 5,
          rate: 1 / FPS,
          color_code: [50, 205, 50]
        });
        BvR.arena.addEntity(f);
      }
      return this.flags.finished = true;
    }

  };

  Selector = class Selector {
    constructor() {
      this.start = false;
      this.end = false;
      this.bindKeys();
    }

    bindKeys() {
      var getOffsets;
      getOffsets = function(e) {
        var x, y;
        x = e.x - arena.offsetParent.offsetLeft - arena.offsetLeft + arena.clientLeft + window.pageXOffset;
        y = e.y - arena.offsetParent.offsetTop - arena.offsetTop - arena.clientTop + window.pageYOffset;
        return [x, y];
      };
      document.oncontextmenu = function(e) {
        return e.preventDefault();
      };
      document.onselectstart = function(e) {
        return e.preventDefault();
      };
      document.onmousemove = (e) => {
        if (this.start) {
          return this.end = getOffsets(e);
        }
      };
      document.onmousedown = (e) => {
        var entity, i, m, position, ref, results;
        position = getOffsets(e);
        switch (e.button) {
          case 0:
            return this.start = position;
          case 2:
            ref = BvR.arena.entities;
            results = [];
            for (i in ref) {
              entity = ref[i];
              if (entity.flags.selected) {
                if (e.shiftKey) {
                  entity.move(position, true);
                } else {
                  entity.move(position);
                }
                m = new MoveIndicator({
                  position: position
                });
                results.push(BvR.arena.addEntity(m));
              } else {
                results.push(void 0);
              }
            }
            return results;
        }
      };
      document.onmouseup = (e) => {
        var entity, i, ref, ref1, results, x, y;
        if (e.button === 0) {
          this.selectRegion(this.start, this.end);
          [x, y] = getOffsets(e);
          ref = BvR.arena.entities;
          results = [];
          for (i in ref) {
            entity = ref[i];
            if (((ref1 = entity.properties) != null ? ref1.selectable : void 0) && Math.pow(entity.position[0] - x, 2) + Math.pow(entity.position[1] - y, 2) < RADIUS_2) {
              entity.flags.selected = true;
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };
      return document.onkeydown = (e) => {
        var entity, i, ref, ref1, results, results1;
        switch (e.keyCode) {
          case 27: // esc
            return this.deselectAll();
          case 72: // h
            ref = BvR.arena.entities;
            results = [];
            for (i in ref) {
              entity = ref[i];
              if (entity.flags.selected) {
                results.push(entity.flags.moving = false);
              } else {
                results.push(void 0);
              }
            }
            return results;
            break;
          case 84: // t
            ref1 = BvR.arena.entities;
            results1 = [];
            for (i in ref1) {
              entity = ref1[i];
              if (entity instanceof Ring && entity.flags.selected) {
                results1.push(entity.berserk());
              } else {
                results1.push(void 0);
              }
            }
            return results1;
        }
      };
    }

    draw() {
      if (this.start && this.end) {
        context.fillStyle = SELECTOR_FILL;
        context.fillRect(this.start[0], this.start[1], this.end[0] - this.start[0], this.end[1] - this.start[1]);
        context.strokeStyle = SELECTOR_BORDER;
        context.lineWidth = 3;
        context.rect(this.start[0], this.start[1], this.end[0] - this.start[0], this.end[1] - this.start[1]);
        return context.stroke();
      }
    }

    mainLoop() {
      return this.draw();
    }

    deselectAll() {
      var e, i, ref, ref1, results;
      ref = BvR.arena.entities;
      results = [];
      for (i in ref) {
        e = ref[i];
        if ((ref1 = e.properties) != null ? ref1.selectable : void 0) {
          results.push(e.flags.selected = false);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }

    selectRegion(start, end) {
      var e, i, ref, ref1, x, xs, y, ys;
      xs = start[0] < end[0] ? [start[0], end[0]] : [end[0], start[0]];
      ys = start[1] < end[1] ? [start[1], end[1]] : [end[1], start[1]];
      ref = BvR.arena.entities;
      for (i in ref) {
        e = ref[i];
        if ((ref1 = e.properties) != null ? ref1.selectable : void 0) {
          [x, y] = e.position;
          e.flags.selected = (xs[0] < x && x < xs[1]) && (ys[0] < y && y < ys[1]);
        }
      }
      return this.start = this.end = false;
    }

  };

  CollisionGrid = class CollisionGrid {
    constructor() {
      this.grid_lookup = {};
      this.id_lookup = {};
      this.initializeLookupTable();
    }

    initializeLookupTable() {
      var j, ref, results, x, y;
      results = [];
      for (x = j = 0, ref = ARENA_WIDTH / GRID_SIZE; (0 <= ref ? j <= ref : j >= ref); x = 0 <= ref ? ++j : --j) {
        results.push((function() {
          var k, ref1, results1;
          results1 = [];
          for (y = k = 0, ref1 = ARENA_HEIGHT / GRID_SIZE; (0 <= ref1 ? k <= ref1 : k >= ref1); y = 0 <= ref1 ? ++k : --k) {
            results1.push(this.grid_lookup[[x, y]] = {});
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    updateEntity(id, position) {
      var j, junk, len, ref, results, x, x0, xy, y, y0;
      if (!(id && position)) {
        return;
      }
      x = [~~((position[0] - RADIUS) / GRID_SIZE), ~~((position[0] + RADIUS) / GRID_SIZE)];
      if (x[0] === x[1]) {
        x = [x[0]];
      }
      y = [~~((position[1] - RADIUS) / GRID_SIZE), ~~((position[1] + RADIUS) / GRID_SIZE)];
      if (y[0] === y[1]) {
        y = [y[0]];
      }
      ref = this.id_lookup[id];
      for (xy in ref) {
        junk = ref[xy];
        delete this.grid_lookup[xy][id];
      }
      this.id_lookup[id] = {};
      results = [];
      for (j = 0, len = x.length; j < len; j++) {
        x0 = x[j];
        results.push((function() {
          var k, len1, results1;
          results1 = [];
          for (k = 0, len1 = y.length; k < len1; k++) {
            y0 = y[k];
            this.id_lookup[id][[x0, y0]] = true;
            results1.push(this.grid_lookup[[x0, y0]][id] = true);
          }
          return results1;
        }).call(this));
      }
      return results;
    }

    detectCollisions(id) {
      var collisions, e, i, junk, p, ref, ref1, x, xy, y;
      [x, y] = BvR.arena.entities[id].position;
      collisions = {};
      ref = this.id_lookup[id];
      for (xy in ref) {
        junk = ref[xy];
        ref1 = this.grid_lookup[xy];
        for (i in ref1) {
          junk = ref1[i];
          if (i + '' !== id + '') {
            if (e = BvR.arena.entities[i]) {
              p = e.position;
              if (Math.pow(p[0] - x, 2) + Math.pow(p[1] - y, 2) <= 4 * RADIUS_2) {
                collisions[i] = p;
              }
            } else {
              BvR.arena.deleteEntity(i);
            }
          }
        }
      }
      return collisions;
    }

    handleCollisions(id) {
      var e0, i, offset, position, ref, results;
      e0 = BvR.arena.entities[id];
      ref = this.detectCollisions(id);
      results = [];
      for (i in ref) {
        position = ref[i];
        offset = [(e0.position[0] - position[0]) * 0.1, (e0.position[1] - position[1]) * 0.1];
        results.push(e0.setPosition([e0.position[0] + offset[0], e0.position[1] + offset[1]]));
      }
      return results;
    }

  };

  window.BvR = {
    arena: new Arena(),
    selector: new Selector(),
    collisions: new CollisionGrid(),
    frame: 0,
    stats: {
      kills: 0,
      units: 0,
      wave: 1
    },
    selectors: {
      kills: document.getElementById('kills-count'),
      units: document.getElementById('units-count'),
      wave: document.getElementById('wave-count')
    }
  };

  BvR.arena.firstWave();

}).call(this);
